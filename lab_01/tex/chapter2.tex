\chapter{Пересчет динамических приоритетов}

Планирование \cite{cospect} --- это организация очереди процессов, то есть постановка процессов в очередь. Планирование бывает с приоритетами и без приоритетов.

Приоритет --- это некоторое число, характеризующее степень привилегированности процесса. Чем выше приоритет, тем меньше времени будет проводить поток в очередях. Различают два вида приоритетов \cite{cospect}:

\begin{itemize}
    \item[---] статические приоритеты --- такие приоритеты назначаются процессам до начала их выполнения и при выполнении не меняются;
    \item[---] динамические приоритеты --- приоритеты, изменяющиеся в процессе выполнения.
\end{itemize}

Динамически могут пересчитываться только приоритеты пользовательских процессов\footnote{Код пользовательского приложения запускается в пользовательском режиме, а код операционной системы запускается в режиме ядра. Предоставляя программному обеспечению операционной системы более высокий уровень привилегий, нежели прикладному программному обеспечению, процессор гарантирует, что приложения с неправильным поведением не смогут нарушить стабильность работы системы \cite{win5}.} (как в Unix, так и в Windows). 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%            UNIX              %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Unix}

В современных системах Unix ядро является строко вытесняющим --- процесс в режиме ядра может быть вытеснен более приоритетным процессом, также находящимся в режиме ядра. Это сделано для того, чтобы система могла обслуживать процессы реального времени, такие как аудио и видео.

Согласно приоритетам процессов и принципу вытесняющего циклического планирования формируется очередь готовых к выполнению процессов. Первыми будут выполняться процессы с большим приоритетом. Процессы с одинаковыми приоритетами выполняются в течение кванта времени, циклически друг за другом.

Приоритет задается любым целым числом, лежащим в диапазоне от 0 до 127. Чем меньше такое число, тем выше приоритет. Приоритеты от 0 до 49 зарезервированы для ядра, следовательно, прикладные процессы могут обладать приоритетом в диапазоне от 50 до 127 \cite{unix5}. 

\begin{table}[h]
	\begin{center}
		\captionsetup{justification=raggedright,singlelinecheck=off}
		\caption{\label{tbl:best}Поля структуры {\ttfamily proc}, относящиеся к приоритетам.}
		\begin{tabular}{lll}
			\hline
			p\_pri & Текущий приоритет планирования \\
			p\_usrpri & Приоритет режима задачи \\
			p\_cpu & Результат последнего измерения использования процессора \\
			p\_nice & Фактор \guillemotleftлюбезности\guillemotright, устанавливаемый пользователем \\
			\hline
		\end{tabular}
	\end{center}
\end{table}

Для принятия решения о том, какой процесс отправить на выполнение, планировщик использует {\ttfamily p\_pri}. Когда процесс находится в режиме задачи, значение его {\ttfamily p\_pri} идентично {\ttfamily p\_usrpri}. Когда процесс просыпается после блокирования в системном вызове, его приоритет будет временно повышен для того, чтобы дать ему предпочтение для выполнения в режиме ядра. 

Ядро системы связывает приоритет сна с событием или ожидаемым ресурсом, из-за которого процесс может заблокироваться. Приоритет сна является величиной, определяемой для ядра, и потому лежит в диапазоне 0-49. Когда замороженный процесс просыпается, ядро устанавливает значение его {\ttfamily p\_pri} равным приоритету сна события или ресурса.
Когда же процесс находится в состоянии возврата в режим задачи, его приоритет сбрасывается обратно в значение текущего приоритета в режиме задачи.

Таким образом, планировщик использует {\ttfamily p\_usrpri} для хранения приоритета, который будет назначен процессу при возврате в режим задачи, а {\ttfamily p\_pri} --- для хранения временного приоритета для выполнения в режиме ядра \cite{unix5}.

\begin{table}[h]
	\begin{center}
		\captionsetup{justification=raggedright,singlelinecheck=off}
		\caption{\label{tbl:best2}Приоритеты сна в системе 4.3BSD UNIX и SCO UNIX \cite{unixR}.}
		\begin{tabular}{lcc}
			\hline
			\textbf{Событие} & \textbf{4.3BSD} & \textbf{SCO} \\
                \hline
			Ожидание загрузки страницы/сегмента & 0 & 95 \\
		      Ожидание индексного дескриптора & 10 & 88 \\
                Ожидание ввода/вывода  & 20 & 81 \\
                Ожидание буфера         & 30 & 80 \\
                Ожидание терминального ввода &  & 75 \\
                Ожидание терминального вывода  &  & 74 \\
                Ожидание завершения выполнения &  & 73 \\
                Ожидание события & 40 & 66 \\
			\hline
		\end{tabular}
	\end{center}
\end{table}

\begin{table}[h]
	\begin{center}
		\captionsetup{justification=raggedright,singlelinecheck=off}
		\caption{\label{tbl:best1}Приоритеты сна в системе 4.3BSD UNIX \cite{unix6}.}
		\begin{tabular}{lcl}
			\hline
			\textbf{Приоритет} & \textbf{Значение} & \textbf{Описание} \\
                \hline
			PSWP          & 0     & Свопинг \\
		      PSWP + 1      & 1     & Страничный демон \\
                PSWP + 1/2/4  & 1/2/4 & Другие действия по обработке памяти \\
                PINOD         & 10    & Ожидание освобождения inode \\
                PRIBIO        & 20    & Ожидание дискового ввода-вывода \\
                PRIBIO + 1    & 21    & Ожидание освобождения буфера \\
                PZERO         & 25    & Базовый приоритет \\
                TTIPRI        & 28    & Ожидание ввода с терминала \\
                TTOPRI        & 29    & Ожидание вывода с терминала \\
                PWAIT         & 30    & Ожидание завершения процесса потомка \\
                PLOCK         & 35    & Консультативное ожидание блокир. ресурса \\
                PSLEP         & 40    & Ожидание сигнала \\
			\hline
		\end{tabular}
	\end{center}
\end{table}


\newpage

Приоритет в режиме задачи зависит от двух факторов \cite{unix5}:

\begin{itemize}
    \item[---] фактор \guillemotleftлюбезности{\guillemotright}\footnote{Степень любезности называется так потому, что одни пользователи могут быть поставлены в более выгодные условия другими пользователями посредством увеличения кем-либо из последних значения уровня любезности для своих менее важных процессов \cite{unix5}} {\ttfamily p\_nice} --- число в диапазоне от 0 до 39 со значением 20 по умолчанию. Чем меньше значение фактора \guillemotleftлюбезности{\guillemotright}, тем выше приоритет процесса. Пользователи могут повлиять на приоритет процесса при помощи изменения этого фактора, используя системный вызов nice (но только суперпользователь имеет полномочия увеличивать приоритет процесса);

    \item[---] фактор \guillemotleftутилизации{\guillemotright} {\ttfamily p\_cpu} --- число в диапазоне от 0 до 127. При создании процесса {\ttfamily p\_cpu} инициализируется нулем. На каждом тике обработчик таймера увеличивает значение этого поля на единицу, пока не дойдет до максимального значения равного 127. Этот фактор позволяет системе динамически изменять приоритет процесса.
\end{itemize}

Каждую секунду ядро системы вызывает процедуру {\ttfamily schedcpu()}, которая уменьшает значение {\ttfamily p\_cpu} каждого процесса исходя из фактора \guillemotleftполураспада{\guillemotright}. 
В системе SVR3 используется фиксированное значение этого фактора, равное $1/2$. В системе 4.3BSD фактор полураспада считается по формуле:

\begin{equation}
\label{eq:ref1}
decay = \frac{2 \cdot load\_average}{2 \cdot load\_average + 1}
\end{equation} где
\textit{load\_average} --- это среднее количество процессов, находящихся в состоянии готовности к выполнению, за последнюю секунду.

Процедура {\ttfamily schedcpu()} также пересчитывает приоритеты для режима задачи всех процессов по формуле:

\begin{equation}
\label{eq:ref2}
p\_usrpri = PUSER + \frac{p\_cpu}{2} + 2 \cdot p\_nice
\end{equation}где \textit{PUSER} --- базовый приоритет в режиме задачи, равный 50.

Таким образом, если процесс в последний раз (то есть до вытеснения его другим процессом) использовал большое количество процессорного времени, его {\ttfamily p\_cpu} будет увеличен. Это приведен к росту {\ttfamily p\_usrpri} и, следовательно, к понижению приоритета. Чем дольше процесс простаивает в очереди на выполнение, тем больше фактор \guillemotleftполураспада{\guillemotright} уменьшает его {\ttfamily p\_cpu}, что приводит к повышению приоритета. Такая схема предотвращает зависание низкоприоритетных процессов по вине операционной системы \cite{unix5}.

Применение этой схемы предпочтительнее процессам, которые осуществляют много операций ввода-вывода (имеют высокий приоритет, так как много времени проводят в ожидании завершения своих операций), в противоположность процессам, производящим много вычислений (используют большое количество процессорного времени, производя много вычислений, поэтому их приоритет после вытеснения понижается) \cite{unix5}.

\subsubsection*{Вывод}

Таким образом, приоритет процесса может быть динамически пересчитан по следующим причинам:

\begin{itemize}
    \item[---] приоритет может быт повышен до соответствующего приоритета сна вследствие ожидания ресурса или события;
    \item[---] вследствие изменения фактора \guillemotleftлюбезности{\guillemotright} процесса системный вызовом {\ttfamily nice};
    \item[---] в зависимости от степени загруженности процессора процессом;
    \item[---] вследствие ожидания процесса в очереди готовых к выполнению процессов.
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%            WINDOWS           %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Windows}

В Windows реализуется приоритетная, вытесняющая система планирования, при которой всегда выполняется хотя бы один работоспособный поток с самым высоким приоритетом, с той оговоркой, что конкретные, имеющие высокий приоритет и готовые к запуску потоки могут быть ограничены процессами, на которых им разрешено или предпочтительнее всего работать \cite{win6}. 

После того как поток был выбран для запуска, он запускается на время, называемое квантом. Поток может не израсходовать свой квант времени: если становится готов к запуску поток с более высоким приоритетом, текущий выполняемый поток может быть вытеснен. Фактически, поток может быть выбран на запуск следующим и вытеснен еще даже до начала своего кванта времени \cite{win6}.

Код планировщик Windows реализован в ядре. Но единого модуля или процедуры под названием \guillemotleftпланировщик\guillemotright не существует, код разбросан по ядру, где происходят события, связанные с планированием. Процедуры выполняющие эти обязанности, обобщенно называются диспетчером ядра. Диспетчеризации потоков могут потребовать следующие события \cite{win6}:

\begin{itemize}
	\item[---] поток становится готовым к выполнению;
	\item[---]  поток выходит из состояния выполнения из-за окончания его кванта времени;
	\item[---]  поток завершается или переходит в состояние ожидания;
	\item[---]  изменяется приоритет потока;
	\item[---]  изменяется родственность процессора потока.
\end{itemize}

Windows использует 32 уровня приоритета, от 0 до 31. Эти значения  разбиваются на части следующим образом:
\begin{itemize}
		\item[---] шестнадцать уровней реального времени (от 16 до 31);
		\item[---] шестнадцать изменяющихся уровней (от 0 до 15), из которых уровень 0 зарезервирован для потока обнуления страниц. 
\end{itemize}

\img{75mm}{s1}{Уровни приоритета потоков в Windows \cite{win6}}

Уровни приоритетов потоков назначаются исходя из двух разных позиций: одной от Windows API и другой от ядра Windows. Сначала Windows API систематизирует процессы по классу приоритета, который им присваивается при создании:

\begin{table}[h]
	\begin{center}
		\captionsetup{justification=raggedright,singlelinecheck=off}
		\caption{\label{tbl:best3}Классы приоритетов в Windows API \cite{win6}.}
		\begin{tabular}{llc}
			\hline
			\textbf{Приоритет (русс.)} & \textbf{Приоритет (англ.)} & \textbf{Номер} \\
                \hline
			реального времени & real-time & 4 \\
                высокий & high & 3 \\
                выше обычного & above normal & 7 \\
                обычный & normal & 2 \\
                ниже обычного & below normal & 5 \\
                простой & idle & 1 \\
			\hline
		\end{tabular}
	\end{center}
\end{table}

Затем назначается относительный приоритет отдельных потоков внутри этих процессов. Здесь номера представляют изменение приоритета, применяющееся к базовому приоритету процесса. Другими словами,  относительный приоритет --- это приращение к базовому приоритету процесса.

\begin{table}[h]
	\begin{center}
	\captionsetup{justification=raggedright,singlelinecheck=off}
		\caption{\label{tbl:best3}Относительный приоритет потока внутри процесса \cite{win6}.}
		\begin{tabular}{llc}
			\hline
			\textbf{Приоритет (русс.)} & \textbf{Приоритет (англ.)} & \textbf{Номер} \\
                \hline
			критичный по времени & time-critical & 15 \\
                наивысший & highest & 2 \\
                выше обычного & above normal & 1 \\
                обычный & normal & 0 \\
                ниже обычного & below normal & -1 \\
                самый низший & lowest & -2 \\
                простой & idle & -15 \\
			\hline
		\end{tabular}
	\end{center}
\end{table}

Соответствие между приоритетами Windows API и ядра Windows приведено в таблице \ref{tbl:priority} \cite{win6}.
\begin{table}[h]
        \captionsetup{justification=raggedright,singlelinecheck=off}
	\caption{Соответствие между приоритетами Windows API и ядра Windows}
	\begin{center}
		\begin{tabular}{|l|p{45pt}|p{45pt}|p{45pt}|p{45pt}|p{45pt}|p{45pt}|} 
			\hline
			{} & \textbf{real-time} & \textbf{high} & \textbf{above normal} & \textbf{normal} & \textbf{below normal} & \textbf{idle}\\
			\hline
			\textbf{time critical} & 31 & 15 & 15 & 15 & 15 & 15 \\
			\hline
			\textbf{highest} & 26 & 15 & 12 & 10 & 8 & 6 \\
			\hline
			\textbf{above normal} & 25 & 14 & 11 & 9 & 7 & 5 \\
			\hline
			\textbf{normal} & 24 & 13 & 10 & 8 & 6 & 4 \\
			\hline
			\textbf{below normal} & 23 & 12 & 9 & 7 & 5 & 3 \\
			\hline
			\textbf{lowest} & 22 & 11 & 8 & 6 & 4 & 2 \\
			\hline
			\textbf{idle} & 16 & 1 & 1 & 1 & 1 & 1 \\
			\hline
		\end{tabular}
	\end{center}
	\label{tbl:priority}
\end{table}

Приложения пользователя обычно запускаются с базовым приоритетом ({\ttfamily normal}), поэтому их исходный поток чаще всего выполняется с уровнем приоритета 8. 

У процесса имеется только одно базовое значение приоритета, а у каждого потока имеется два значения приоритета: текущее (динамическое) и базовое. Решения по планированию принимаются исходя из текущего приоритета. Система при определенных обстоятельствах на короткие периоды времени повышает приоритет потоков в динамическом диапазоне (от 1 до 15). Windows никогда не регулирует приоритет потоков в диапазоне реального времени (от 16 до 31), поэтому они всегда имеют один и тот же базовый и текущий приоритет \cite{win6}.

Исходный базовый приоритет потока наследуется от базового приоритета процесса. Процесс по умолчанию наследует свой базовый приоритет у того процесса, который его создал \cite{win6}.

Планировщик Windows периодически настраивает текущий приоритет потоков, используя внутренний механизм повышения приоритета. Во многих случаях это делается для уменьшения различных задержек и повышения восприимчивости системы, а также чтобы у потоков была возможность выполнения и освобождения ресурсов. Другими словами, это повышение применяется для предотвращения
сценариев смены приоритетов и зависаний \cite{win7}. 


Повышение приоритета вступает в действие немедленно и может вызвать изменения в планировании процессора. Однако если поток использует весь свой следующий квант, то он теряет один уровень приоритета. Если же он использует второй полный квант, то он перемещается вниз еще  на один уровень, и так до тех пор, пока не дойдет до своего базового уровня. 

Сценарии повышения приоритета \cite{win7}:
\begin{itemize}
	\item[---] повышение вследствие событий планировщика или диспетчера (сокращение задержек);
	\item[---] повышение вследствие завершения ввода-вывода (сокращение задержек --- поток может вновь запуститься и начать новую операцию ввода-вывода). В таблице \ref{tab:io} приведены рекомендуемые значения повышения приоритета для устройств ввода-вывода;
	\item[---] повышение вследствие ввода из пользовательского интерфейса (сокращение задержек и времени отклика);
	\item[---] повышение приоритета владельца блокировки;
	\item[---] повышение вследствие слишком продолжительного ожидания ресурса исполняющей системы (предотвращение зависания);
	\item[---] повышение в случае, когда готовый к запуску поток не был запущен в течение определенного времени (чтобы исключить бесконечное откладывание процессов);
	\item[---] повышение вследствие ожидания объекта ядра;
	\item[---] повышение приоритета потоков первого плана после ожидания (улучшение отзывчивости интерактивных приложений);
	\item[---] повышение приоритета после пробуждения GUI-потока (потоки-владельцы окон получают при пробуждении дополнительное повышение приоритета на 2);
	\item[---] повышения приоритета, связанные с перезагруженностью центрального процессора (CPU Starvation);
	\item[---] другие псевдоповышающие 	механизмы, проявляющие себя при проигрывании мультимедиа. В отличие от других повышений приоритета, эти механизмы применяются непосредственно в режиме ядра. Повышение приоритета проигрывания мультимедиа управляется службой планировщика класса мультимедиа MMCSS (это не является настоящим повышением).
\end{itemize}

\begin{table}[h]
\captionsetup{justification=raggedright,singlelinecheck=off}
	\caption{Рекомендуемые значения повышения приоритета \cite{win7}.}
	\begin{center}
		\begin{tabular}{p{100mm}c}
			\hline
			\textbf{Устройство} & \textbf{Приращение} \\
			\hline
			Диск, CD-ROM, параллельный порт, видео & 1 \\
			% \hline
			Сеть, почтовый ящик, именованный канал, последовательный порт & 2 \\
			% \hline
			Клавиатура, мышь & 6 \\
			% \hline
			Звуковая плата & 8 \\
			\hline
		\end{tabular}
	\end{center}
	\label{tab:io}
\end{table}

Рассмотрим последние два сценария подробней. 

\subsubsection*{Перезагруженность центрального процессора}

В Windows включен общий механизм ослабления загруженности центрального процессора, который называется диспетчером настройки баланса и является частью системного потока \cite{win8}.

Один раз в секунду этот поток сканирует очередь готовых потоков в поиске тех из них, которые находятся в состоянии ожидания около 4 секунд. Если такой поток будет найден, диспетчер настройки баланса повышает его приоритет до 15 единиц и устанавливает квантовую цель эквивалентной тактовой частоте процессора при подсчете 3 квантовых единиц. Как только квант истекает, приоритет потока тут же снижается до обычного базового приоритета. Если поток не был завершен и есть готовый к запуску поток с более высоким уровнем приоритета, поток с пониженным приоритетом возвращается в очередь готовых потоков.

Для минимизации времени своей работы, диспетчер настройки баланса сканирует только 16 готовых потоков. Если на данном уровне приоритета имеется больше потоков, он запоминает то место, на котором остановился, и начинает с него при следующем проходе очереди. Кроме того, он за один проход повысит приоритет только 10 потоков. Если найдет 10 потоков, заслуживающих именно этого повышения, он прекратит сканирование на этом месте и начнет его с этого же места при следующем проходе.

\subsubsection*{MMCSS}

MMCSS работает с вполне определенными задачами, включая следующие: аудио, захват, распределение, игры, проигрывание, аудио профессионального качества, задачи администратора многооконного режима \cite{win9}.

Каждая из этих задач включает информацию о свойствах, отличающих их друг от друга. Одно из наиболее важных свойств для планирования потоков называется категорией планирования --- Scheduling Category, которое является первичным фактором, определяющим приоритет потоков, зарегистрированных с MMCSS. На рисунке \ref{img:6} показаны различные категории планирования.

\img{70mm}{6}{Категории планирования изменение приоритета}

\newpage

Механизм, положенный в основу MMCSS, повышает приоритет потоков
внутри зарегистрированного процесса до уровня, соответствующего их категории
планирования и относительного приоритета внутри этой категории на гарантированный срок. Затем он снижает категорию этих потоков до Exhausted, чтобы другие, не относящиеся к мультимедийным приложениям потоки, также могли получить ресурс.

\subsubsection*{IRQL}

Для обеспечения поддержки мультизадачности системы, когда исполняется код режима ядра, Windows использует приоритеты прерываний IRQL \cite{win10}. 

Прерывания обслуживаются в порядке их приоритета. При возникновении прерывания с высоким приоритетом процессор сохраняет информацию о состоянии прерванного потока и активизирует сопоставленный с данным прерыванием диспетчер ловушки. Последний повышает IRQL и вызывает
процедуру обслуживания прерывания (ISR). После выполнения ISR диспетчер прерывания понижает IRQL процессора до исходного уровня и загружает сохраненные ранее данные о состоянии машины. Прерванный поток возобновляется с той точки, где он был прерван. Когда ядро понижает IRQL, могут начать обрабатываться ранее замаскированные прерывания с более низким приоритетом. Тогда вышеописанный процесс повторяется ядром для обработки и этих прерываний.


