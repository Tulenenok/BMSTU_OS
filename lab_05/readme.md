# Монитор Хоара (под винду)

## Введение

Семафорные механизмы имеют ряд недостатков:

* семафор не указывает непостредственно на синхронизирующее условие или на критический ресурс
* при построении сложных схем синхронизации алгоритмы решения задач порой получаются весьма непростыми, ненаглядными и затруднительными для доказательства их правильности

Поэтому нужен механизм, который позволил бы программистам без лишних усилий создавать параллельные взаимодействующие программы.

## Монитор

Монитор (в параллельном программировании) -- это механизм организации параллелизма, который содержит как данные, так и процедуры, необходимые для реализации динамического распределения конкретного общего ресурса или группы общих ресурсов.

> Есть планировщик, ресур и процессы.
> Когда процесс желает получить ресурс, он обращается к планировщику.
> Планировщик имеет переменные, по которым он определяет занят ресурс или свободен.
> При этом процедуру-планировщик разделяют все процессы.
> А обслужить больше одного процесса одновременно нельзя.
>
> Вот эта процедура планировщик и есть монитор.

Про алгоритм работы более подробно:

* процесс, желая получить доступ к разделяемым переменным, должен обратиться к монитору 
* вход в монитор находится под жестким контролем -- здесь осуществляется взаимоисключение процессов (в каждый момент времени только один процесс может войти в монитор)
* если монитор занят, то процессу приходится ждать. Причем режимом ожидания автоматически управляет сам монитор -- он блокирует обратившийся к нему процесс и определяет условие, по которому процесс ждет (проверку условия осуществляет монитор)
* если процесс обращается к некоторой процедуре и обнаруживается, что ресурс уже занят, процедура выдает команду ожидания WAIT с указанием условия ожидания. 
* при этом процесс ждет вне монитора, пока процесс освободиться (чтобы не противоречить принципу взаимоисключения)
* когда ресурс возвращается системе, соответствующая процедура монитора или ждет пока не придет заявка на этот ресурс или выполнит команду извещения SIGNAL, чтобы один из ожидающих процессов мог получить данный реурс и покинуть монитор

Еще одна причина, почему важно, чтобы ожидающий ресурс процесс ждал вне монитора:

> Другому процессу, когда он захочет вернуть ресурс, нужно будет зайти в монитор -- монитор должен быть свободен.

Как сделать так, чтобы ожидающий процесс не ждал ресурс вечно?

> Ожидающий процесс имеет более высокий приоритет, чем новый процесс, пытающийся войти в монитор. В противном случае новый процесс мог бы перехватить ожидаемый ресурс до того, как ожидающий процесс вновь войдетв монитор.
>
> (для систем реального времени можно допустить использование дисциплины обслуживания на основе абсолютных или динамически изменяемых приоритетов)

## Некоторые преимущества подхода

* использование монитора освобождает процессы от необходимости явно разделять между собой информацию
* доступ к разделяемым переменным ограничен телом монитора -> разделяемые переменные становятся системными переменными (так как монитор входит в состав ядра ос) -> это автоматически исключает критические интервалы (два процесса никогда не будут пользоваться ресурсом одновременно)
* мониторы очень гибки -- в форме мониторов можно реализоваать не только семафоры, но и многие другие синхронизирующие операции
* локализация всех разделяемых переменных внутри тела монитора позволяет избавиться от малопонятных конструкций в синхронизируемых процессах
* мониторы дают возможность совместно использовать программные модули, представляющие собой критические секции (не нужно для каждого процесса иметь собственный экземпляр критической секции)

ИТОГ: мониторы обеспечивают по сравнению с семафорами значительное упрощение организации взаимодействующих процессов и большую наглядность при незначительной потере в эффективности.

------

## Читатели-писатели

### Постановка задачи

Реализовать классический монитор Хоара на примере задачи "читатели-писатели" с использованием событий и с включением в программу одного мьютекса.

Использовать четыре функции:

* `BeginWrite()` - функция блокировки разделяемого ресурса для его инкемента
* `EndWrite()` - функция снятия блокировки с разделяемого ресурса после записи
* `BeginRead()` - функция блокировки разделяемого ресурса для выполнения операции чтения
* `EndRead()` - функция снятия блокировки с разделяемого ресурса после завершения операции чтения

В качестве разделяемого ресурса использовать счетчик, который в процессе работы писателя инкрементируется на 1. Минимальное количество писателей и читателей. -- 5 и 3 соответственно.

Предполагаются следующие правила работы потоков:

* когда один поток пишет в область общих данных -- другие потоки не могут ни считывать, ни записывать в эту область
* когда один поток читает из области общих данных -- другие потоки не могут туда ничего записывать, но могут читать данные

### Решение

Для работы с монитором будем использовать параллельные потоки.

У нас будет переменная `writeLock` - когда писатель работает она будет иметь истинное значение.

Переменная `readers` - указывает количество активных читателей. Когда количество читателей оказывается равным нулю, ожидающий поток-писатель получает возможность начать работу. 

Есть два события `CanRead` (со сбосом вручную) и `CanWrite` (с автоматическим сбросом). Новый поток читатель не может продолжить свое выполнение, пока не настанет событие `CanRead`. А новый поток писатель -- пока не настанет событие `CanWrite`.

Когда читателю необходимо выполнить чтение данных, он вызывает процедуру входа в монитор `BeginRead`, затем инкрементирует переменную `queueReaders`, показывая свое присутствие в очереди на чтение данных новому потоку-писателю, поток-читатель может находиться внутри функции `BeginRead` пока никакой другой писатель не пишет данные и не претендует на выполнение записи данных.

Функция `BeginRead` завершается оповещением переменной `CanRead`, чтобы другие ждущие потоки смогли продолжить чтение данных.

По окончанию процесса чтение читатель вызывает функцию `EndRead`, в ней читател уменьшает переменную `readers` на 1, сокращая тем самым количество активных читателей. Когда в системе не остается ни одного читателя, поток выдается команду оповещения `CanWrite`, чтобы писатели смогли продолжить работу (тем самым исключая бесконечное откладывание ждущих писателей)

### Схема работы читателя

<img width="638" alt="image-20221113171348769" src="https://pro-prof.com/wp-content/uploads/2020/02/flowchart-hoar_2.png">

### Схема работы писателя 

<img width="638" alt="image-20221113171348769" src="https://pro-prof.com/wp-content/uploads/2020/02/flowchart-hoar_1.png">

-----

## Реализация

Первое, что бы делаем -- настраиваем события `can_read` и `can_write`. Для этого используем функции [`CreateEvent`](https://learn.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-createeventa)

```c
HANDLE CreateEvent
(
	LPSECURITY_ATTRIBUTES lpEventAttributes,	// атрибут защиты
	BOOL bManualReset,											  // тип сброса TRUE - ручной
	BOOL bInitialState,											  // начальное состояние TRUE - сигнальное
	LPCTSTR lpName														// имя обьекта
);
```

Получаем следующий код инициализации:

``` c
HANDLE can_write;
HANDLE can_read;

int init()
{
    // Атрибут защиты по умолчанию, ручной сброс, состояние сигнальное, имя нет
    // Первый нул также говорит о том, что дескриптор не может быть унаследован
    // дочерними процессами
    can_write = CreateEvent(NULL, TRUE, TRUE, NULL);
    if(can_write == NULL)
    {
        perror("Error with CreateEvent (can_write)");
        return -1;
    }

  
    // FALSE -- система будет сбрасывать состояние события на nonsigned после освобождения
    // одного ожидающего потока
    can_read = CreateEvent(NULL, FALSE, TRUE, NULL);
    if(can_read == NULL)
    {
        perror("Error with CreateEvent (can_read)");
        return -1;
    }
    
    return 0;
}
```

---

Теперь нам нужно создать потоки читателей и потоки писателей. Для этого используем функцию [`CreateThread`](https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createthread).

```c
HANDLE CreateThread(
  [in, optional]  LPSECURITY_ATTRIBUTES   lpThreadAttributes, // атрибут защиты
  [in]            SIZE_T                  dwStackSize,				// начальный размер стека 
  [in]            LPTHREAD_START_ROUTINE  lpStartAddress,			// начальный адрес потока
  [in, optional]  __drv_aliasesMem LPVOID lpParameter,				// указатель на переменную, которая будет передана потоку
  [in]            DWORD                   dwCreationFlags,	  // флаг управления потоком
  [out, optional] LPDWORD                 lpThreadId				  // 	указатель на переменную, которая получит идентификатор потока
);
```

```c
int init_threads()
{
    for(int i = 0; i < 3; i++)
    {
        writers_id[i] = i;
        writers_threads[i] = CreateThread(NULL, 0, &init_writer, writers_id + i, 0, NULL);        

        if (writers_threads[i] == NULL)
        {
            perror("Error with CreateThread (writer)");
            return -1;
        }
...
```

-----

Здесь встает вопрос -- что такое инициализация читателя и писателя. 

Будем считать инициализацией 8 записей или чтения переменной.

```c
DWORD WINAPI init_writer(CONST LPVOID param)
{
    int id = *(int *)param;
    int sleep_time;

    for(int i = 0; i < 8; i++)
    {
        sleep_time = 100 + rand() * time(NULL) % 400;
        Sleep(sleep_time);

        // здесь начинается критическая секция
        start_write();

        ++shared_variable;
        printf("init_writer: %d  ----> write: %d\n", id, shared_variable);

        stop_write();
        // критическая секция закончилась 
    }
}
```

---

Что такое start и stop?

* Для писателя

  Чтобы писатель мог начать писать ему нужен сигнал `can_write` -> `start_write` ожидает получение этого сигнала.

  ```c
  void start_write()
  {
      WaitForSingleObject(can_write, INFINITE);
  }
  ```

  Когда писатель заканчивает работу ему нужно отправить в мир сигнал, что можно читать.

  ```c
  void stop_write()
  {
      SetEvent(can_read);
  }
  ```

* Для читателя

  Чтобы начать читать, читателю необходимо получить сигнал, что можно читать и сигнал, что можно писать (!!!). После чего он сбрасывает сигнал можно писать (чтобы никто не начал писать) и увеличивает переменную количество активных читателей на 1.

  ```c
  void start_read()
  {
      WaitForSingleObject(can_read, INFINITE);
      WaitForSingleObject(can_write, INFINITE);
      ResetEvent(can_write);
  
      InterlockedIncrement(&count_active_readers);
  }
  ```

  Заканчивая чтения, читатель отправляет сигнал другим читателям сигнал на возможность чтения.

  Если же он был последним в очереди читателей, то он отправляет сигнал писателям, что можно читать.

  ```c
  void stop_read()
  {
      InterlockedDecrement(&count_active_readers);
  
      SetEvent(can_read);
  
      if(count_active_readers == 0)
          SetEvent(can_write);
  }
  ```

-----

Осталось только все аккуратно закрыть

* Во-первых, ждем, пока все потоки отработают с помощью функции [`WaitForMultipleObjects`](https://learn.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-waitformultipleobjects)

  ```c
  void wait_threads()
  {
      // TRUE -- ждем все, а не один
      WaitForMultipleObjects(3, writers_threads, TRUE, INFINITE);
      WaitForMultipleObjects(5, writers_threads, TRUE, INFINITE);
  }
  ```

* Во-вторых, закрываем все обработчики

  ```c
  void close_handles()
  {
      for(int i = 0; i < 3; i++)
          CloseHandle(writers_threads[i]);
  
      for(int i = 0; i < 5; i++)
          CloseHandle(readers_threads[i]);
  
      CloseHandle(can_write);
      CloseHandle(can_read);
  }
  ```

## Источники

1. [Общие термины](https://studfile.net/preview/5946428/page:72/)
2. [Решение задачи читатели-писатели](https://pro-prof.com/forums/topic/hoar_modelling)
3. [Некоторые функции](https://firststeps.ru/mfc/winapi/r.php?119)

