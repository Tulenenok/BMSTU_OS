

# Файловая система

Разберемся в общих чертах в устройстве файловой системы UNIX. Представим себе диск, поделенный на несколько разделов. Каждый из разделов может содержать файловую систему, как показано на рисунке.

![image-20230219162416571](/Users/gurovana/Library/Application Support/typora-user-images/image-20230219162416571.png)

**Индексные узлы** -- это записи фиксированной длины, которые содержат большую часть сведений о файлах.

* тип файлаа
* биты прав доступа
* размер файла
* указатели на блоки данных файла

Файл каталога содержит такую информацию, как 

* имя файла
* номер индексного узла

Присмотревшись ближе к той части группы цилиндров, где находятся индексные узлы и блоки данных, можно увидеть следующую картину

![image-20230219162702557](/Users/gurovana/Library/Application Support/typora-user-images/image-20230219162702557.png)

Особенности:

1. Здесь есть две зааписи в файле каталога, которые ссылаются на один и тот же индексный узел. При этом каждый индексный узел имеет счетчик ссылок, где хранится число записей в файле каталога, которые ссылаются на данный индексный узел.

   0 -> файл удален -> блоки данных, связанные с файлом, перешли в список свободных блоков

   Поэтому unlink (отцепить) != delete (удалить)

2. Нельзя создать каталожную запись, которая указывала бы на индексный узел в другой файловой системе

3. При переименовании/перемещении файла в пределах одной и той же ФС фактическое содержимое файла никуда не перемещается. В каталог добавляется новая запись, которая указывает на существующий индексный узел, а старая запись отцепляется.

### Счетчик ссылок для каталога

Выполним команду `mkdir testdir`

![image-20230219163833886](/Users/gurovana/Library/Application Support/typora-user-images/image-20230219163833886.png)

# Сокеты

Сокет -- это абстракция конечной точки взаимодействия. 

## Дескриптор сокета

Для работы с сокетами используются дескрипторы сокетов, которые в юникс организованы так же, как дескрипторы файлов. 

```c
#include <sys/socket.h>

int socket(int domain, int type, int protocol);
// Создает дескриптор сокета и возвращает его в случае успеха, -1 в случае ошибки
```

### domain

Аргумент domain определяет природу взаимодействия, включая формат адреса.

| Домен       | Описание             |
| ----------- | -------------------- |
| `AF_INET`   | Домен Интернета IPv4 |
| `AF_INET6`  | Домен Интернета IPv6 |
| `AF_UNIX`   | Домен UNIX           |
| `AF_UNSPEC` | Неопределенный домен |

> Имена констант начинаются с префикса AF_ (address family - семейство адресов), потому что каждый домен обладает своим собственным форматом представления адресов.

### type

Тип сокета, который определяет характеристики взаимодействия. 

| Тип              | Описание                                                     |
| ---------------- | ------------------------------------------------------------ |
| `SOCK_DGRAM`     | Не ориентированы на создание логического соединения, сообщения фиксированной длинны, доставка сообщений не гарантируется |
| `SOCK_RAW`       | Интерфейс дейтаграмм к протоколу IP                          |
| `SOCK_SEQPACKET` | Ориентированы на создание логического соединения, упорядоченность передачи данных, сообщения фиксированной длины, гарантируется доставка сообщений |
| `SOCK_STREAM`    | Ориентированы на создание логического соединения, упорядоченность передачи данных, гарантируется доставка сообщений, двунаправленный поток байтров. |

### protocol

Обычно передается 0, чтобы выбрать значение по умолчанию для данного домена и типа сокета. 

| Домен     | Тип              | Протокол по умолчанию                                        | Особенности                                                  |
| --------- | ---------------- | :----------------------------------------------------------- | ------------------------------------------------------------ |
| `AF_INET` | `SOCK_STREAM`    | `TCP` (Transmission Control Protocol) -- протокол управления передачей данных | Потоки байтов требуют, чтобы перед началом обмена данными между нашим сокетом и сокетом, принадлежащим сетевому узлу, с которым предполагается взаимодействовать, было установлено логическое соединение (аналогия -- телефонный звонок) |
| `AF_INET` | `SOCK_DGRAM`     | `UDP` (User Datagram Protocol) -- протокол пользовательских дейтаграмм | Дейтаграммы -- это служба, не ориентированная на установление логического соединения.  <br /> <br />При использовании дейтаграмм не требуется устанавливать логическое соединение. Все, что нужно сделать -- это переда ть сообщение по адресу сокета, который используется процессом на другом конце (аналогия -- письма по почте) |
| `AF_INET` | `SOCK_SEQPACKET` | `SCTP` (Stream Control Tramsmission Protocol) -- протокол передачи с управлением потоком | Услуга передачи отдельных сообщений -- очень похожи на  `SOCK_STREAM`, но вместо приема/передачи в виде потока байтов, могут работать с отдельными сообщениями |
| `AF_INET` | `SOCK_RAW`       | `IP` ?                                                       | Сокеты `SOCK_RAW` представляют собой интерфейс дейтаграмм на сетевом уровне (то есть интерфейс к протоколу `IP` в домене интернет). При использовании этого интерфейса вся ответственность за построение заголовков пакетов возлагается на приложения (так как не используются протоколы транспотрного уровня TCP или UDP). Приложению нужно обладать правами суперпользователя. |



## Функции для работы с сокетами

Приведу перечень самых основных (остальные можно посмотреть в приложении)

| Функция | Поведение при работе с сокетом                           |
| ------- | -------------------------------------------------------- |
| `close` | Освободить сокет                                         |
| `read`  | Эквивалентно вызову функции `recv` без каких-либо флагов |
| `write` | Эквивалентно вызову функции `send` без каких-либо флагов |

Обмен данными через сокеты является двунаправленный. Выполнение отделных операций над сокетами можно запретить с помощью функции `shutdown`

```c
#include <sys/socket.h>

int shutdown(int sockfd, int how);
// how == SHUT_RD - запретить чтение из сокета
// how == SHUT_WR - запретить запись в сокет
// how == SHUT_RDWR - запретить возможность передачи в обоих направлениях
```

Отличия `shutdown` от `close`:

1. `close` закроет соединение и освободит дескриптор только тогда, когда будет закрыта последняя активная ссылка на сокет. `shutdown` позволяет деактивировать сокет независимо от количества ссылающихся на него активных дескриптов.
2. Возможность запретить передачу данных в одном направлении. 

## Адресация

Как происходит идентификация процесса, с которым мы хотим взаимодействовать? Идентификационная част состоит из двух частей:

1. Сетевой адрес компютера 

   Позволяет идентифицировать сетевой узел, с которым мы предполагаем вступить в контакт

2. Номер службы 

   Позволяет идентифицировать конкретный процесс на этом компьютере

### Порядок байтов

-- характеристика аппаратной архитектуры процессора, определяющая, в каком порядке следуют байты в данных длинных типов (н. целые числа).

| Название                 | Описание                                             | Иллюстрация                                                  |
| ------------------------ | ---------------------------------------------------- | ------------------------------------------------------------ |
| Обратный (`big-endian`)  | В старшем адресе располагается младший значащий байт | ![image-20230219151134498](/Users/gurovana/Library/Application Support/typora-user-images/image-20230219151134498.png) |
| Прямой (`little-endian`) | Младщий значащий байт хранится в младщем адресе      | ![image-20230219151147608](/Users/gurovana/Library/Application Support/typora-user-images/image-20230219151147608.png) |

```
!!! Независимо от порядка байт СЗБ всегда слева, а МЗБ - справа.
0x04030201 - СЗБ имеет значение 4, младщий 1, независимо от порядка байтов.

Порядок проявляется в ссылках: если сделать char *, то
  -- на машине с прямым порядком cp[0] ссылается на младщий байт -> 1
  -- на машине с обратным порядком cp[0] ссылается на старший -> 4
```

| ОС            | Архитектура процессора | Порядок  |
| ------------- | ---------------------- | -------- |
| FreeBSD 5.2.1 | Intel Pentium          | Прямой   |
| Linux 2.4.22  | Intel Pentium          | Прямой   |
| Mac OS X 10.3 | PowerPC                | Обратный |
| Solaris 9     | Sun SPARC              | Обратный |

### Порядок байт в протоколах

При использовании протоколов TCP/IP используется **сетевой (обратный)** порядок байтов.

Преобразования между сетевым и аппаратным порядком производятся с помощью следующих функций

```c
#include <arpa/inet.h>

uint32_t htonl(uint32_t hostint32); // вернуть 32-битное целое с сетевым порядком байтов
uint16_t htons(uint16_t hostint16); // вернуть 16-битное целое с сетевым порядком байтов

uint32_t ntohl(uint32_t netint32);  // вернуть 32-битное целое с аппаратным порядком байтов
uint16_t ntohs(uint16_t netint16);  // вернуть 16-битное целое с аппаратным порядком байтов
```

> n -- network (сетевой порядок байтов)
>
> h -- host (аппаратный)
>
> l -- long 
>
> s -- short

### Форматы адресов

Адреса используются для идентификации сокетов в конкретном домене. Обощенная структура адреса:

```c
struct sockaddr {
  sa_family sa_family; /* семейство адресов */
  char 			sa_data[]; /* адрес переменной длины */
  ...
}
```

Как мне показалось, далее идет информация, которую окончательно невозможно присвоить этой лабе, поэтому вернуть к ней позже, когда будем изучать сокеты (стр. ~648)

## Приложение

Функции работы с сокетами

