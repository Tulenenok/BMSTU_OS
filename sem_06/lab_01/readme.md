

# Файловая система

## Определения из лекции

**Файл** (Оксвордский словарь вычислительной техники) -- это информация хранимая во вторичной памяти или во вспомагательном запоминающем устройстве с целью ее сохранения после завершения отдельного задания или преодоления ограничений связанных с объемом основного запоминающего устройства.

В файле могут содержаться данные, программы, тексты и любая другая информация.

**Файл** (Рязанова) -- поименованная совокупность данных, хранимая во вторичной памяти.

**Файловая система** -- это порядок, определяющий способ организации хранения, именования и доступа к данным на вторичных носителях информации.

> Вторичная память обеспечивает **долговременное хранение** (то есть она должна быть энерго независимой)

**Задача файловой системы** -- обеспечивать сохранение данных и доступ к сохраненным данным.

----

Разберемся в общих чертах в устройстве файловой системы UNIX. Представим себе диск, поделенный на несколько разделов. Каждый из разделов может содержать файловую систему, как показано на рисунке.

![image-20230219162416571](img/img_01.jpg)

**Индексные узлы** -- это записи фиксированной длины, которые содержат большую часть сведений о файлах.

* тип файлаа
* биты прав доступа
* размер файла
* указатели на блоки данных файла

Файл каталога содержит такую информацию, как 

* имя файла
* номер индексного узла

Присмотревшись ближе к той части группы цилиндров, где находятся индексные узлы и блоки данных, можно увидеть следующую картину

![image-20230219162416571](img/img_04.jpg)

Особенности:

1. Здесь есть две зааписи в файле каталога, которые ссылаются на один и тот же индексный узел. При этом каждый индексный узел имеет счетчик ссылок, где хранится число записей в файле каталога, которые ссылаются на данный индексный узел.

   0 -> файл удален -> блоки данных, связанные с файлом, перешли в список свободных блоков

   Поэтому unlink (отцепить) != delete (удалить)

2. Нельзя создать каталожную запись, которая указывала бы на индексный узел в другой файловой системе

3. При переименовании/перемещении файла в пределах одной и той же ФС фактическое содержимое файла никуда не перемещается. В каталог добавляется новая запись, которая указывает на существующий индексный узел, а старая запись отцепляется.

### Счетчик ссылок для каталога

Выполним команду `mkdir testdir`

![image-20230219162416571](img/img_07.png)

# Сокеты

Сокет -- это абстракция конечной точки взаимодействия. 

## Дескриптор сокета

Для работы с сокетами используются дескрипторы сокетов, которые в юникс организованы так же, как дескрипторы файлов. 

```c
#include <sys/socket.h>

int socket(int domain, int type, int protocol);
// Создает дескриптор сокета и возвращает его в случае успеха, -1 в случае ошибки
```

### domain

Аргумент domain определяет природу взаимодействия, включая формат адреса.

| Домен       | Описание             |
| ----------- | -------------------- |
| `AF_INET`   | Домен Интернета IPv4 |
| `AF_INET6`  | Домен Интернета IPv6 |
| `AF_UNIX`   | Домен UNIX           |
| `AF_UNSPEC` | Неопределенный домен |

> Имена констант начинаются с префикса AF_ (address family - семейство адресов), потому что каждый домен обладает своим собственным форматом представления адресов.

### type

Тип сокета, который определяет характеристики взаимодействия. 

| Тип              | Описание                                                     |
| ---------------- | ------------------------------------------------------------ |
| `SOCK_DGRAM`     | Не ориентированы на создание логического соединения, сообщения фиксированной длинны, доставка сообщений не гарантируется |
| `SOCK_RAW`       | Интерфейс дейтаграмм к протоколу IP                          |
| `SOCK_SEQPACKET` | Ориентированы на создание логического соединения, упорядоченность передачи данных, сообщения фиксированной длины, гарантируется доставка сообщений |
| `SOCK_STREAM`    | Ориентированы на создание логического соединения, упорядоченность передачи данных, гарантируется доставка сообщений, двунаправленный поток байтров. |

### protocol

Обычно передается 0, чтобы выбрать значение по умолчанию для данного домена и типа сокета. 

| Домен     | Тип              | Протокол по умолчанию                                        | Особенности                                                  |
| --------- | ---------------- | :----------------------------------------------------------- | ------------------------------------------------------------ |
| `AF_INET` | `SOCK_STREAM`    | `TCP` (Transmission Control Protocol) -- протокол управления передачей данных | Потоки байтов требуют, чтобы перед началом обмена данными между нашим сокетом и сокетом, принадлежащим сетевому узлу, с которым предполагается взаимодействовать, было установлено логическое соединение (аналогия -- телефонный звонок) |
| `AF_INET` | `SOCK_DGRAM`     | `UDP` (User Datagram Protocol) -- протокол пользовательских дейтаграмм | Дейтаграммы -- это служба, не ориентированная на установление логического соединения.  <br /> <br />При использовании дейтаграмм не требуется устанавливать логическое соединение. Все, что нужно сделать -- это переда ть сообщение по адресу сокета, который используется процессом на другом конце (аналогия -- письма по почте) |
| `AF_INET` | `SOCK_SEQPACKET` | `SCTP` (Stream Control Tramsmission Protocol) -- протокол передачи с управлением потоком | Услуга передачи отдельных сообщений -- очень похожи на  `SOCK_STREAM`, но вместо приема/передачи в виде потока байтов, могут работать с отдельными сообщениями |
| `AF_INET` | `SOCK_RAW`       | `IP` ?                                                       | Сокеты `SOCK_RAW` представляют собой интерфейс дейтаграмм на сетевом уровне (то есть интерфейс к протоколу `IP` в домене интернет). При использовании этого интерфейса вся ответственность за построение заголовков пакетов возлагается на приложения (так как не используются протоколы транспотрного уровня TCP или UDP). Приложению нужно обладать правами суперпользователя. |



## Функции для работы с сокетами

Приведу перечень самых основных (остальные можно посмотреть в приложении)

| Функция | Поведение при работе с сокетом                           |
| ------- | -------------------------------------------------------- |
| `close` | Освободить сокет                                         |
| `read`  | Эквивалентно вызову функции `recv` без каких-либо флагов |
| `write` | Эквивалентно вызову функции `send` без каких-либо флагов |

Обмен данными через сокеты является двунаправленный. Выполнение отделных операций над сокетами можно запретить с помощью функции `shutdown`

```c
#include <sys/socket.h>

int shutdown(int sockfd, int how);
// how == SHUT_RD - запретить чтение из сокета
// how == SHUT_WR - запретить запись в сокет
// how == SHUT_RDWR - запретить возможность передачи в обоих направлениях
```

Отличия `shutdown` от `close`:

1. `close` закроет соединение и освободит дескриптор только тогда, когда будет закрыта последняя активная ссылка на сокет. `shutdown` позволяет деактивировать сокет независимо от количества ссылающихся на него активных дескриптов.
2. Возможность запретить передачу данных в одном направлении. 

## Адресация

Как происходит идентификация процесса, с которым мы хотим взаимодействовать? Идентификационная част состоит из двух частей:

1. Сетевой адрес компютера 

   Позволяет идентифицировать сетевой узел, с которым мы предполагаем вступить в контакт

2. Номер службы 

   Позволяет идентифицировать конкретный процесс на этом компьютере

### Порядок байтов

-- характеристика аппаратной архитектуры процессора, определяющая, в каком порядке следуют байты в данных длинных типов (н. целые числа).

| Название                 | Описание                                             | Иллюстрация                                |
| ------------------------ | ---------------------------------------------------- | ------------------------------------------ |
| Обратный (`big-endian`)  | В старшем адресе располагается младший значащий байт | ![image-20230219162416571](img/img_05.png) |
| Прямой (`little-endian`) | Младщий значащий байт хранится в младщем адресе      | ![image-20230219162416571](img/img_06.png) |

```
!!! Независимо от порядка байт СЗБ всегда слева, а МЗБ - справа.
0x04030201 - СЗБ имеет значение 4, младщий 1, независимо от порядка байтов.

Порядок проявляется в ссылках: если сделать char *, то
  -- на машине с прямым порядком cp[0] ссылается на младщий байт -> 1
  -- на машине с обратным порядком cp[0] ссылается на старший -> 4
```

| ОС            | Архитектура процессора | Порядок  |
| ------------- | ---------------------- | -------- |
| FreeBSD 5.2.1 | Intel Pentium          | Прямой   |
| Linux 2.4.22  | Intel Pentium          | Прямой   |
| Mac OS X 10.3 | PowerPC                | Обратный |
| Solaris 9     | Sun SPARC              | Обратный |

### Порядок байт в протоколах

При использовании протоколов TCP/IP используется **сетевой (обратный)** порядок байтов.

Преобразования между сетевым и аппаратным порядком производятся с помощью следующих функций

```c
#include <arpa/inet.h>

uint32_t htonl(uint32_t hostint32); // вернуть 32-битное целое с сетевым порядком байтов
uint16_t htons(uint16_t hostint16); // вернуть 16-битное целое с сетевым порядком байтов

uint32_t ntohl(uint32_t netint32);  // вернуть 32-битное целое с аппаратным порядком байтов
uint16_t ntohs(uint16_t netint16);  // вернуть 16-битное целое с аппаратным порядком байтов
```

> n -- network (сетевой порядок байтов)
>
> h -- host (аппаратный)
>
> l -- long 
>
> s -- short

### Форматы адресов

Адреса используются для идентификации сокетов в конкретном домене. Обощенная структура адреса:

```c
struct sockaddr {
  sa_family sa_family; /* семейство адресов */
  char 			sa_data[]; /* адрес переменной длины */
  ...
}
```

Формат представления адресов Интернетаа определен в заголовочном фале `<netinet/in.h`. Адреса сокетов из домена `IPv4` представлены структурой 

```c
struct in_addr {
  in_addr_t s_addr; 		/* 	адрес IPv4 */
};

struct sockaddr_in {
  sa_family      sa_family;   /* семейство адресов */
  in_port_t      sin_port;    /* номер порта */
  struct in_addr sin_addr;    /* адрес IPv4 */
}
```

Адреса сокетов домена Интернет IPv6 представлены структурой `sockaddr_ip6`.



Иногда возникает необходимость выводить адреса в виде, удобном для человека. Для этого есть функции:

* `inet_ntop` -- преобразует адрес из двоичного представления с сетевым порядком батов в текстовую строку
* `inet_pton` -- преобразует текствую строку в двоичное представление с сетевым порядком байтов.

```c
#include <anpa/inet.h>
cons chat *inet_ntop(int domain, const void *restrict addr,
                    char *restrict str, socklen_t size);
/* Возвращает указатель на строку с адресом в случае успеха, NULL в случае ошибки */
```

```c
int inet_pton(int domain, const char *restrict str, void *restrict addr);
/* Возвращает 1 в случае успеха, 0 при неверном формате, -1 в случае ошибки */
```

## Определение адреса

> 📍 В идеале приложения ничего не должны знать о внутренней структуре адреса сокета. 

Информация о конфигурации сети может храниться в статических файлах (`/etc/hosts`, `/etc/services` и другие) или предоставляться различными сетевыми службами, такими как `DNS` (Domain Name System -- система доменных имен) и `NIS` (Network Information Service -- сетевая информационная служба). Независимо от того, где хранится информация, для доступа к ней используются одни и те же функции.

Адреса хостов, известных заданной системе, могут быть получены с помощью функции `gethostent`.

```c
#include <netdb.h>
struct hostent *gethostent(void); 
// Возвращает указатель на очередную запись из файла с данными об адресах или NULL

void sethostent(int stayopen);
// Открывает файл или переходит в его начало, если он уже открыт

void endhostent(void);
// Закрывает файл
```

Когда функция `gethostent` возвращает управление, мы получаем указатель на структуру `hostent`, которая может размещаться в области статической памяти, которая будет затерта при следующем обращении к этой функции.

```c
struct hostent {
  char *h_name;					/* имя хоста */
  char **h_aliases;			/* указатель на массив псевдонимов */
  int h_addrtype; 			/* тип адреса */
  int h_length;					/* длина адреса в байтах */
  char **h_addr_list;		/* указатель на массив сетевых адресов */
  ...
}
```

Возвращаемые адреса имеют **сетевой порядок байтов**.

Получение имен сетей и их номеров (номер сети имеет сетевой порядок байтов):

```c
#include <netdb.h>
struct netent *getnetbyaddr(uint32_t net, int type);
struct netent *getnetbyname(const char *name);
struct netent *getnetent(void);
// Все возвращают указатель в случае успеха, NULL в случае ошибки

void setnetent(int stayopen);
void endnetent(void);

struct netent {
  char *n_name;			/* имя сети */
  char **n_aliases;	/* указатель на массив псевдонимов сети */
  int n_addrtype;   /* тип адреса */
  unit32_t n_net;		/* номер сети */
  ...
}
```

Преобразования между именами протоколов и их номерами производятся с помощью следующих наборов функций:

```c
#include <netdb.h>
struct protoent *getprotobyname(const chat *name);
struct protoent *getprotobynumber(int proto);
struct protoent *getprotoent(void);
// Все возвращают указатель в случае успеха, NULL в случае ошибки

void setprotoent(int stayopen);
void endproroent(void);

struct protoent {
  char *p_name;				/* имя протокола */
  char **p_aliases;		/* указатель на массив псевдонимов протокола */
  int p_proto;				/* номер протокола */
}
```

Службы определяются номером порта, который является частью адреса. Каждой сетевой службе присвоен свой уникальный номер порта

```c
#include <netdb.h>
struct servent *getservbyname(const char *name, const char *proto);
// Получить номер порта по имени службы

struct servent *getservbyport(int port, const char *proto);
// Получить имя службы по номеру порта

struct servent *getservent(void);
// Последовательно посмотрет все записи в базе данных служб

void setservent(int stayopen);
void endservent(void);

struct servent {
  char *s_name;				/* имя службы */
  char ** s_aliases;  /* указатель на массив псведонимов службы */
  int s_port;					/* номер порта */
  char *s_proto;			/* имя протокола */
  ...
}
```

Получить сетевой адрес из имени хоста и имени службы.

```c
#include <sys/socket.h>
#include <netdb.h>

int getaddrinfo(const char *restrict host, const char *restrict service,
               const struct addrinfo *restrict hint,
               struct addrinfo **restrict res);
void freeaddrinfo(struct addrinfo *ai);

struct addrinfo {
  int ai_flags;										// флаги
  int ai_family;									// семейство адресов
  int ai_socktype;								// тип сокета
  int ai_protocol;								// протокол
  socklen_t ai_addrlen;						// длина адреса в байтах 
  struct sockaddr *ai_addr;				// адрес
  char *ai_canonname;							// каноническое имя хоста
  struct addrinfo *ai_next;				// следующий элемент списка
}

// Флаги для работы с этой структурой можно посмотреть в приложении
```





## Приложение

Функции работы с сокетами

![image-20230219162416571](img/img_03.jpg)

![image-20230219162416571](img/img_02.jpg)

Флаги для стукрутры addrinfo

![image-20230219162416571](img/img_08.png)
