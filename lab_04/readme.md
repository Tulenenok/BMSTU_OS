# Семафоры

## Введение

**Семафор** - это счетчик, который используется для предоставления доступа к данным, совместно используемым несколькими процессами.

## Процессы и семафоры

Чтобы получить доступ к ресурсу, находящемуся в совместном использовании, процесс должен:

1. **Проверить состояние семафора**, который регулирует доступ к этому ресурсу
2. Если **семафор имеет положительное значение**, процесс **может обратиться к ресурсу**. В этом случае процесс уменьшает значение семафора на 1 (указывая тем самым, что он использовал единицу ресурса)
3. В противном случае, если **семафор имеет значение 0**, **процесс приостанавливается** до тех пор, пока значение семафора не станет > 0. После этого процесс восстановит работу и вернется к шагу 1.

4. **По окончании работы** с ресурсом, доступ к которому регулируется семафором, **значение семафора будет увеличено на 1**.

Для корректной работы семафоров необходимо, чтобы проверка состояния семафора и его уменьшение выполнялись в виде атомарной операции. По этой причине семафоры обычно **реализуются внутри ядра**.

*Атомарная операция — операция, которая либо выполняется целиком, либо не выполняется вовсе*

## Особенности семафоров

1. Семафор - это не просто одиночное неотрицательное значение. Чтобы определить семафор, необходимо определить **набор** из одного или более семафоров. (количество семафоров в наборе задается при создании этого набора)
2. **Создание набора** семафоров (`semget`) **происходит независимо от его инициализации** (`semctl`). Это очень серьезный недостаток, поскольку невозможно атомарно создать новый набор семафоров и инициализировать их значения.
3. Поскольку **семафоры продолжают существовать даже после завершения процессов**, их использующих, необходимо предусматривать в программах алгоритмы освобождения размещенных ранее наборов семафоров. 

## Семафоры в ядре

Каждому набору семафоров ядро ставит в соответствие структуру `semid_ds`

```c
struct semid_ds {
  struct ipc_perm sem_perm;   // Структура прав доступа 
  unsigned short sem_nsems;   // Кол-во семафоров в наборе 
  time_t sem_otime;           // Время последнего вызова semop() 
  time_t sem_ctime;           // Время последнего изменения 
}
```

Каждый из семафоров представлен в наборе анонимной структурой, которая содержит как минимум следующие поля:

```c
struct {
  unsigned short semval;   // Значение семафора 
  pid_t sempid;            // ID процесса, выполнившего посл. операцию
  // Кол-во процессов, ожидающих выполнения условия semval > curval
  unsigned short semncnt;  
  // Кол-во процессов, ожидающих выполнения условия semval == 0
  unsigned short semzcnt;
}
```

Системные пределы, которые имеют отношение к наборам семафоров можно посмотреть в приложении.

## Работа с семафорами

### Semget

Обычно при работе с семафорами прежде всего вызывается функия `semget`, которая возвращает **идентификатор набора семафоров** (или -1 в случае ошибки).

```c
#include <sys/sem.h>

int semget(key_t key, int nsems, int flag);
```

При создании нового набора инициализируются следующие поля структуры `semid_ds`:

1. Структура `ipc_perm` инициализируется, при этом поле `mode` устанавливается в соответствии со значениями битов прав доступа в аргументе `flag`. (конкретные значения см в приложении)
2. В поле sem_otime записывается 0
3. В поле sem_ctime записывается значение текущего времени
4. В поле sem_nsems записывается значение аргумента nsems.

*Замечание*. Если при вызове набор не создается, а открывается существующий, то допускается передать в `nsems` 0. Создание или открытие будет определять параметр `key`. Ключ `IPC_PRIVATE` гарантирует создание новой структуры (но там много тонкостей см. 15.6.1)

### Semctl

С помощью этой функции выполняются операции над набором семафоров.

```c
#include <sys/sem.h>

int semctl(int semid, int semnum, int cmd, ... /* union semun arg */ );

/*
 * Четвертый аргумент функции является необязательным и зависит от
 * выполняемой команды - если он присутствует, то представляет собой
 * объединение semun различных аргументов команд:
 */

union semun {
  int val;                // для SETVAL
  struct semid_ds *buf;   // для IPC_STAT и IPC_SET
  unsigned short *arry;   // для GETALL и SETALL
}

// !!! Четвертый аргумент является объединением, а не указателем
// на объединение
```

Что определяют аргументы здесь?

*  `cmd` определяет одну из 10 операций, которые могут выполняться над набором семафоров
* `semid` - идентификатор набора семафоров
* `semnum` - номер семафора в наборе (нужен для 5 команд)

В случае всех GET-команд кроме GETALL, функция возвращает соответствующее значение вызывающему процессу. Для остальных команд возвращается 0.

|  Команда   | Описание                                                     | Особенности                                                  |
| :--------: | :----------------------------------------------------------- | ------------------------------------------------------------ |
| `IPC_STAT` | Получить структуру `semid_ds`, которая соответствует заданному набору семафоров | Структура будет сохранена  по адресу `arg.buf`               |
| `IPC_SET`  | Установить значения полей `sem_perm.uid`, `sem_perm.gid` и `sem_perm.mode` в соответствии со значениями этих же полей в структуре, на которую укзывает `arg.buf`. | Команда может быть выполнена процессом только в том случае, если его эффективный идентификатор пользователя совпадает со значением `sem_perm.cuid` или `sem_perm.uid` или если процесс обладает привилегиями супер пользователя. |
| `IPC_RMID` | Удалить набор семафоров. Удаление происходит немедленно. Все процессы, которые продолжают использовать набор семафоров, получат код ошибки `EIDRM` при первой же попытке обращения к нему. | Команда может быть выполнена процессом только в том случае, если его эффективный идентификатор пользователя совпадает со значением `sem_perm.cuid` или `sem_perm.uid` или если процесс обладает привилегиями супер пользователя. |
|  `GETVAL`  | Вернуть значение поля `semval` для семафора с номером `semnun`. |                                                              |
|  `SETVAL`  | Установить значение поля `semval` для семафора с номером `semnum`. | Значение определяется в  `arg.val`                           |
|  `GETPID`  | Вернуть значение поля `sempid` для семафора с номером `semnum` |                                                              |
| `GETNCNT`  | Вернуть значение поля `semcnt` для семафора с номером `semnum`. |                                                              |
| `GETZNCNT` | Вернуть значение поля `semzcnt` для семафора с номером `semnum` |                                                              |
|  `GETALL`  | Вернуть значения всех семафоров в наборе.                    | Значения сохраняются в массиве, на который указывает `arg.array` |
|  `SETALL`  | Уставновить значения всех семафоров в наборе.                | Значения берутся из массива, на который указывает `arg.array` |

 

### Semop

Выполнить сразу несколько операций над набором семафоров. 

Функция выполняет все операции атомарно - будут выполнены либо все запрошенные дейстивия, либо ни одно их них.

```c
#include <sys/sem.h>

int semop(int semid, struct sembuf semoparray[], size_t nops);

// Возвращает 0 в случае успеха, -1 в случае ошибки
```

Значения аргументов:

* `nops` - определяет количество операция (элементов) в массиве

* `semoparray` - массив указателей на операции с семафорами, каждая из которых представлена в виде структуры `sembuf`

  ```c
  struct sembuf {
    unsigned short sem_num;    // Кол-во семафоров в наборе 
    short sem_op;              // Операция (<0, 0 или >0)
    short sem_flg;             // IPC_NOWAIT, SEM_UNDO
  }
  ```

  Про `sem_op`:

  1. `sem_op` > 0 - случай, когда процесс освобождает занятые ресурсы. 

     > Значение `sem_op` добавляетя к значению семафора. Если указан флаг `SEM_UNDO`, значение также вычитается из значения корректировки процесса

  2. `sem_op` < 0 - процесс желает получить ресурс, доступ к которому регулируется семафором.

     > Если значение семафора >= абсолютному значению `sem_op`, абсолютное значение вычитается из значения семафора. Если указан флаг `SEM_UNDO`, значение также прибавляется к величине корректировки процесса.
     >
     > Если значение семафора <, то есть ресурс недоступен, то работает все также, как и ниже для семафора > 0, только использовать мы будем `semncnt`,  а не `semzcnt`. 
     >
     > И плюс первое из трех условий будет выглядет следующим образом:
     >
     > * Значение семафора стало >= абсолютному значению `sem_op`. Значение `semcnt` для этого семафора уменьшается и абсолютное значение `sem_op` вычитается из значения семафора. Если указан флаг `SEM_UNDO`, значение также прибавляется к величине корректировки процесса.

  3. `sem_op` = 0 - процесс желает дождатся момента, когда значение семафора достигнет 0.

     > Если значение семафора уже = 0, функция сразу вернет управление.
     >
     > Если значение семафора > 0, тогда 
     >
     > * если указан флаг `IPC_NOWAIT` - функция `semop` возващает управление с кодом ошибки `EAGAIN`
     > * если флаг не указан, то для данного семафора увеличивается значение `semzcnt` и выполнение вызывающего процесса приостаналивается до тех пор, пока не будет соблюдено одно из следующих условий:
     >   * Значение семафора станет = 0. В этом случае значение `semzcnt` уменьшается
     >   * Семафор удаляется из системы. В этом случае функция `semop` вернет признак ошибки с кодом `EIDRM`
     >   * Процессом был перехвачен сигнал и обработчик сигнала вернул управление. Тогда значение `semzcnt` уменьшается и функция  `semop`  вернет признак ошибки с кодом `EINTR`.

## Корректировка семафора по завершении

Проблема: завершение процесса в то время, когда он захватил какие-либо ресурсы посредством семафора.

Решение: всякий раз, когда мы делаем операцию над семафором, устанавливаем флаг `SEM_UNDO`. 

В этом случае ядро будет запомнать, как много ресурсов было захвачено процессом с помощью конкретного семафора. Когда процесс завершается, добровольно или принудительно, ядро проверяет, имеет ли процесс какие-либо невыполненныые корректировки семафоров и, если таковые имеются, корректирует значения соотсвтетствующих семафоров.

# Разделяемая память

## Введение

**Механизм разделяемой памяти** - механизм, позволяющий двум и более процессам совместно использовать одну и ту же область памяти.

**Сложный момент при работе с разделяемой памятью** - синхронизация доступа к ней. Если сервер размещает некоторые данные в области разделяемой памяти, клиент не должен пытаться читать данные до тех пор, пока сервер не выполнит всю работу.

## Разделяемая память и ядро

Каждому сегменту разделяемой памяти ядро ставит в соответствие структуру, которая содержит как минимум следующий набор полей

```c
struct shmid_ds {
  struct ipc_perm shm_perm; // права доступа
  size_t shm_segsz;         // размер сегмента в байтах
  pid_t shm_lpid;           // ID процесса, последним вызвавшего shmop()
  pid_t shm_cpid;           // ID процесса-создателя
  shmatt_t shm_nattch;      // текущее кол-во подключений 
  time_t shm_atime;         // время последнего подключения
  time_t shm_dtime;         // время последнего отключения
  time_t shm_ctime;         // время последнего изменения
}

// Тип shmatt_t определен как беззнаковое поле, по меньшей мере - unsigned short
```

Системные пределы, имеющие отношение разделяемой памяти можно посмотреть в приложении.

## Работа с разделяемой памятью

### Shmget 

Возвращает идентификатор сегмента разделяемой памяти (-1 в случае ошибки)

```c
#include <sys/shm.h>

int shmget(key_t key, size_t size, int flag);
```

При создании сегмента инициализируются следующие поля структуры `shmid_ds`:

1. Cтруктура `ipc_perm` инициализируется, при этом поле `mode` устанавливается в соответствии со значениями битов прав доступа в аргументе `flag`. (конкретные значения см в приложении)

2. В поля `smh_lpid`, `shm_nattach`, `shm_atime` и `shm_dtime` записывается значение 0

3. В поле `shm_ctime` записывается значение текущего времени

4. В поле `shm_segsz` записывается значение аргумента `size`

   Определяет размер сегмента разделяемой памяти. Обычно его округяют так, чтобы число было кратно размеру страницы памяти в системе, потому что иначе остаток послледней страницы все равно не будет доступен для использования.

   Если нужно лишь получить ссылку на существующий сегмент (в случае клиента), то можно передать значение 0. 

! Когда создается новый сегмент его содержимое очищается

### Shmctl

Выполняет различные операции над сегментов разделяемой памяти.

```c
#include <sys/shm.h>

int shmctl(int shmid, int cmd, struct shmid *buf);

// Возвращает 0 в сучае успеха, -1 в случае ошибки
```

`shmid` - над каким сегментом выполняем операцию, `cmd` - код операции

|   Команда    | Описание                                                     | Особенности                                                  |
| :----------: | ------------------------------------------------------------ | ------------------------------------------------------------ |
|  `IPC_STAT`  | Получить структуру `shmid_ds` для данного сегмента памяти    | Структура будет сохранена по адресу `buf`                    |
|  `IPC_SET`   | Скопировать значения полей `shm_perm.uid`, `shm_perm.gid`, `shm_perm.mode` из `buf` в структуру `shmid_ds`, связанную с сегментом разделяемой памяти. | Команда может быть выполнена процессом только в том случае, если его эффективный идентификатор пользователя совпадает со значением `shm_perm.cuid` или `shm_perm.uid` или если процесс обладает привилегиями супер пользователя. |
|  `IPC_RMID`  | Удалить сегмент из разделяемой памяти. Поскольку для сегментов разделяемой памяти поддерживается счетчик ссылок (поле `shm_nattach` в структуре `shmod_ds`), сегмент не будет удален до тех пор, пока последний использующий его процесс не завершиться или не отсоединит этот сегмент. | Команда может быть выполнена процессом только в том случае, если его эффективный идентификатор пользователя совпадает со значением `shm_perm.cuid` или `shm_perm.uid` или если процесс обладает привилегиями супер пользователя. |
|  `SHM_LOCK`  | Заблокировать сегмент разделяемой памяти.                    | Команда может быть выполнена только, если процесс обладает привилегиями супер пользователя. |
| `SHM_UNLOCK` | Разблокировать сегмент разделяемой памяти.                   | Команда может быть выполнена только, если процесс обладает привилегиями супер пользователя. |

### Shmat

С помощью этой команды процесс может присоединить сегмент разделяемой памяти к своему адресному пространству.

```c
#include <sys/shm.h>

void *shmat(int shmid, const void *addr, int flag);

// Возвращает указатель на сегмент разделяемой памяти
// (адрес, начиная с которог было присоединен сегмент)
// -1 в случае ошибки
```

Адрес, начиная с которого будет присоединен сегмент разделяемой памяти, зависит от значения аргумента `addr` и наличия флага `SHM_RND` в аргументе `flag`:

* `addr` = 0 -> сегмент будет присоединен к первому доступному адресу, который выберет ядро.
* `addr` != 0 и флаг `SHM_RND` не указан ->  сегмент присоединяется начиная с адреса `addr`
* `addr` != 0 и флаг `SHM_RND` указан -> сегмент будет присоединен с адреса, который вычисляется по формуле `addr - (addr mod SHMLBA)`

Если в аргументе `flag` указан флаг `SHM_RDONLY`, присоединенный сегмент будет доступен только для чтения (в противном случае для чтения и записи)

Если вызов функции завершился успехом, ядро увеличит счетчик `shm_nattch` в структуре `shmid_ds`, связанной с этим сегментом.

### Shmdt

Отсоединение сегмента разделяемой памяти.

!!! Эта функция не удаляет из системы идентификатор и структуры данных, ассоциированные с сегментом памяти. Идентификатор продолжает существовать до тех пор, пока какой-либо процесс специально не удалит его вызовом функции `shmctl` c комадой `IPC_RMID`

```c
#include <sys/shm.h>
int shmdt(void *addr);

// addr - значение, полученное от функции shmat
// В случае успеха shmdt уменьшит значение счетчика shm_nattch в структуре `shmid_ds
```


# Приложение

### Системные пределы семафоров

<img width="632" alt="image-20221113150657096" src="https://user-images.githubusercontent.com/78147880/201524010-bce0e4aa-4da9-4509-9b50-6b0aa381e964.png">

### Про структуру ipc_perm

```c
struct ipc_perm {
  uid_t uid;  // Эффективный идентификатор пользователя владельца
  gid_t gid;  // Эффективный идентификатор группы владельца
  uid_t cuid; // Эффективный идентификатор пользователя создателя
  gid_t cgid; // Эффективный идентификатор группы создателя
  
  mode_t mode; // Режим доступа
  ...
}
```

Значение поля `mode`:

<img width="600" alt="image-20221113151512563" src="https://user-images.githubusercontent.com/78147880/201524015-008e2de8-2daf-47b2-ab96-1b6231c1ced8.png">

### Системные пределы для разделяемой памяти

<img width="638" alt="image-20221113171348769" src="https://user-images.githubusercontent.com/78147880/201528635-c04d419f-da8b-4973-a595-77ead198d880.png">

### Вопрос - что такое потерянное обновление?
Читатели не могут читать, пока есть активные писатели и ждущие писатели. Из-за этого может теряться значение
![os_04 drawio](https://user-images.githubusercontent.com/78147880/203629617-2c9c577d-6f9a-406e-9c99-9f80ff17d257.svg)

